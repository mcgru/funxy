// Test built-in traits: Equal, Order, Numeric, Default

// Test Order constraint with max function
fun max<T: Order>(a: T, b: T) -> T {
    if a > b { a } else { b }
}

print(max(10, 20))      // 20
print(max(3.5, 2.1))    // 3.5
print(max(100n, 50n))   // 100

// Test Numeric constraint with sum function
fun sum<T: Numeric>(a: T, b: T, c: T) -> T {
    a + b + c
}

print(sum(1, 2, 3))        // 6
print(sum(1.0, 2.0, 3.0))  // 6

// Test Equal constraint
fun allEqual<T: Equal>(a: T, b: T, c: T) -> Bool {
    a == b && b == c
}

print(allEqual(5, 5, 5))        // true
print(allEqual(1, 2, 1))        // false
print(allEqual("a", "a", "a"))  // true

// Test default function
print(default(Int))     // 0
print(default(Float))   // 0
print(default(Bool))    // false

// Test modulo
print(17 % 5)   // 2
print(10 % 3)   // 1
print(-7 % 3)   // -1

// Test custom type implementing built-in Default trait
// Records automatically get default from field defaults
type Point = { x: Int, y: Int }
instance Default Point {}
p: Point = default(Point)
print(p.x)  // 0
print(p.y)  // 0

// ADT type with custom getDefault method
type Counter = MkCounter Int

instance Default Counter {
    fun getDefault(dummy: Counter) -> Counter {
        MkCounter(0)
    }
}

fun unwrap(c: Counter) -> Int {
    match c { MkCounter n -> n }
}

c: Counter = default(Counter)
print(unwrap(c))  // 0
