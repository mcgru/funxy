// =============================================================================
// HKT Step 1: F<A> in function signatures
// =============================================================================
// Goal: Allow type variables to be applied to other type variables
// Example: F<A> where F is a type constructor variable

// -----------------------------------------------------------------------------
// Test 1.1: Simple identity for container (1 type arg)
// -----------------------------------------------------------------------------

// F is a type constructor (like Option, List), A is element type
fun identity<F, A>(fa: F<A>) -> F<A> {
    fa
}

// Should work with Option
opt1 = identity(Some(42))
print(opt1)  // Some(42)

// Should work with List
list1 = identity([1, 2, 3])
print(list1)  // [1, 2, 3]

// -----------------------------------------------------------------------------
// Test 1.2: Identity for two-arg type constructors (like Result)
// -----------------------------------------------------------------------------

fun identity2<F, A, B>(fab: F<A, B>) -> F<A, B> {
    fab
}

// Should work with Result
res1 = identity2(Ok("hello"))
print(res1)  // Ok("hello")

res2 = identity2(Fail(404))
print(res2)  // Fail(404)

// -----------------------------------------------------------------------------
// Test 1.3: Function that transforms inside container
// -----------------------------------------------------------------------------

fun wrap<F, A>(x: A, wrapper: (A) -> F<A>) -> F<A> {
    wrapper(x)
}

opt2 = wrap(10, Some)
print(opt2)  // Some(10)

// -----------------------------------------------------------------------------
// Test 1.4: Two container types in one function
// -----------------------------------------------------------------------------

fun convert<F, G, A>(fa: F<A>, converter: (F<A>) -> G<A>) -> G<A> {
    converter(fa)
}

// Convert Option to List
optToList = fun(opt: Option<Int>) -> List<Int> {
    match opt {
        Some(x) -> [x]
        Zero -> []
    }
}

list2 = convert(Some(5), optToList)
print(list2)  // [5]

list3 = convert(Zero, optToList)
print(list3)  // []

// -----------------------------------------------------------------------------
// Test 1.5: Nested type application F<G<A>>
// -----------------------------------------------------------------------------

fun nested<F, G, A>(fga: F<G<A>>) -> F<G<A>> {
    fga
}

// List of Options
listOpts = nested([Some(1), Some(2), Zero])
print(listOpts)  // [Some(1), Some(2), Zero]

// Option of List
optList = nested(Some([1, 2, 3]))
print(optList)  // Some([1, 2, 3])

print("Step 1 passed!")
