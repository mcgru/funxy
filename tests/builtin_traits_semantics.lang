// =============================================
// Built-in Traits Semantics
// Defines semantic versions of built-in traits in our language
// =============================================

// =============================================
// EqualSemantics<T> — equality comparison
// =============================================
// Built-in: Equal<T> with == and !=
// Semantics: != is derived from ==

trait EqualSemantics<T> {
    fun eq(a: T, b: T) -> Bool
    
    // Default: != derived from ==
    fun neq(a: T, b: T) -> Bool {
        !(eq(a, b))
    }
}

instance EqualSemantics<Int> {
    fun eq(a: Int, b: Int) -> Bool { a == b }
}

instance EqualSemantics<Bool> {
    fun eq(a: Bool, b: Bool) -> Bool { a == b }
}

instance EqualSemantics<Char> {
    fun eq(a: Char, b: Char) -> Bool { a == b }
}

// Test EqualSemantics
print(eq(1, 1))                    // true
print(eq(1, 2))                    // false
print(neq(1, 2))                   // true (default impl)
print(neq(5, 5))                   // false

print((1 == 1) == eq(1, 1))        // true
print((1 != 2) == neq(1, 2))       // true

// =============================================
// OrderSemantics<T> : EqualSemantics<T> — ordering
// =============================================
// Built-in: Order<T> with <, >, <=, >=
// Semantics: only < is required, others derived

trait OrderSemantics<T> : EqualSemantics<T> {
    fun lt(a: T, b: T) -> Bool
    
    // Default: > derived from <
    fun gt(a: T, b: T) -> Bool {
        lt(b, a)
    }
    
    // Default: <= derived from < and ==
    fun lte(a: T, b: T) -> Bool {
        lt(a, b) || eq(a, b)
    }
    
    // Default: >= derived from <=
    fun gte(a: T, b: T) -> Bool {
        lte(b, a)
    }
}

instance OrderSemantics<Int> {
    fun lt(a: Int, b: Int) -> Bool { a < b }
}

instance OrderSemantics<Char> {
    fun lt(a: Char, b: Char) -> Bool { a < b }
}

// Test OrderSemantics
print(lt(3, 5))                    // true
print(gt(5, 3))                    // true (default)
print(lte(5, 5))                   // true (default)
print(gte(5, 3))                   // true (default)

print((3 < 5) == lt(3, 5))         // true
print((5 > 3) == gt(5, 3))         // true
print((5 <= 5) == lte(5, 5))       // true
print((5 >= 3) == gte(5, 3))       // true

// min/max using OrderSemantics
fun minSem<T: OrderSemantics>(a: T, b: T) -> T {
    if lt(a, b) { a } else { b }
}

fun maxSem<T: OrderSemantics>(a: T, b: T) -> T {
    if gt(a, b) { a } else { b }
}

print(minSem(10, 20))              // 10
print(maxSem(10, 20))              // 20

// =============================================
// NumberSemantics<T> — arithmetic operations
// =============================================
// Built-in: Number<T> with +, -, *, /, %, **
// Semantics: all operations are primitive

trait NumberSemantics<T> {
    fun add(a: T, b: T) -> T
    fun sub(a: T, b: T) -> T
    fun mul(a: T, b: T) -> T
    fun div(a: T, b: T) -> T
    fun modulo(a: T, b: T) -> T
    
    // Default: negate using sub
    fun negate(x: T, zero: T) -> T {
        sub(zero, x)
    }
}

instance NumberSemantics<Int> {
    fun add(a: Int, b: Int) -> Int { a + b }
    fun sub(a: Int, b: Int) -> Int { a - b }
    fun mul(a: Int, b: Int) -> Int { a * b }
    fun div(a: Int, b: Int) -> Int { a / b }
    fun modulo(a: Int, b: Int) -> Int { a % b }
}

instance NumberSemantics<Float> {
    fun add(a: Float, b: Float) -> Float { a + b }
    fun sub(a: Float, b: Float) -> Float { a - b }
    fun mul(a: Float, b: Float) -> Float { a * b }
    fun div(a: Float, b: Float) -> Float { a / b }
    fun modulo(a: Float, b: Float) -> Float { a % b }
}

// Test NumberSemantics
print(add(10, 20))                         // 30
print(sub(20, 5))                          // 15
print(mul(6, 7))                           // 42
print(div(100, 4))                         // 25
print(modulo(17, 5))                       // 2
print(negate(5, 0))                        // -5

print((10 + 20) == add(10, 20))            // true
print((20 - 5) == sub(20, 5))              // true
print((6 * 7) == mul(6, 7))                // true
print((100 / 4) == div(100, 4))            // true
print((17 % 5) == modulo(17, 5))           // true

// Power semantics (recursive)
fun powerSem(base: Int, exp: Int) -> Int {
    if exp == 0 { 1 }
    else if exp == 1 { base }
    else { mul(base, powerSem(base, exp - 1)) }
}

print(2 ** 10)                             // 1024
print(powerSem(2, 10))                     // 1024
print((2 ** 10) == powerSem(2, 10))        // true

// Sum using NumberSemantics
fun sumSem(xs: List<Int>) -> Int {
    match xs {
        [] -> 0
        [x, rest...] -> add(x, sumSem(rest))
    }
}

print(sumSem([1, 2, 3, 4, 5]))             // 15

// Product using NumberSemantics
fun productSem(xs: List<Int>) -> Int {
    match xs {
        [] -> 1
        [x, rest...] -> mul(x, productSem(rest))
    }
}

print(productSem([1, 2, 3, 4, 5]))         // 120

// =============================================
// BitwiseSemantics<T> — bitwise operations
// =============================================
// Built-in: Bitwise<T> with &, |, ^, <<, >>

trait BitwiseSemantics<T> {
    fun band(a: T, b: T) -> T    // AND
    fun bor(a: T, b: T) -> T     // OR
    fun bxor(a: T, b: T) -> T    // XOR
    fun shl(a: T, b: T) -> T     // left shift
    fun shr(a: T, b: T) -> T     // right shift
}

instance BitwiseSemantics<Int> {
    fun band(a: Int, b: Int) -> Int { a & b }
    fun bor(a: Int, b: Int) -> Int { a | b }
    fun bxor(a: Int, b: Int) -> Int { a ^ b }
    fun shl(a: Int, b: Int) -> Int { a << b }
    fun shr(a: Int, b: Int) -> Int { a >> b }
}

// Test BitwiseSemantics
print(band(5, 3))                          // 1 (101 & 011 = 001)
print(bor(5, 3))                           // 7 (101 | 011 = 111)
print(bxor(5, 3))                          // 6 (101 ^ 011 = 110)
print(shl(1, 3))                           // 8 (1 << 3)
print(shr(8, 2))                           // 2 (8 >> 2)

print((5 & 3) == band(5, 3))               // true
print((5 | 3) == bor(5, 3))                // true
print((5 ^ 3) == bxor(5, 3))               // true
print((1 << 3) == shl(1, 3))               // true
print((8 >> 2) == shr(8, 2))               // true

// Derived operations using BitwiseSemantics
fun isBitSet(x: Int, bit: Int) -> Bool {
    band(x, shl(1, bit)) != 0
}

fun setBit(x: Int, bit: Int) -> Int {
    bor(x, shl(1, bit))
}

fun clearBit(x: Int, bit: Int) -> Int {
    band(x, sub(sub(0, 1), shl(1, bit)))
}

fun toggleBit(x: Int, bit: Int) -> Int {
    bxor(x, shl(1, bit))
}

print(isBitSet(5, 0))                      // true  (5 = 101)
print(isBitSet(5, 1))                      // false
print(isBitSet(5, 2))                      // true

print(setBit(0, 0))                        // 1
print(setBit(0, 2))                        // 4
print(setBit(1, 2))                        // 5

print(clearBit(7, 1))                      // 5 (111 -> 101)

print(toggleBit(5, 1))                     // 7 (101 -> 111)
print(toggleBit(7, 1))                     // 5 (111 -> 101)

// =============================================
// ConcatSemantics<T> — concatenation
// =============================================
// Built-in: Concat<T> with ++

trait ConcatSemantics<T> {
    fun concatSem(a: T, b: T) -> T
}

// We can't easily make List<A> instance without HKT for the element type
// So we use a wrapper type for demonstration

type IntList = MkIntList List<Int>

fun unwrapIntList(il: IntList) -> List<Int> {
    match il { MkIntList xs -> xs }
}

instance ConcatSemantics<IntList> {
    fun concatSem(a: IntList, b: IntList) -> IntList {
        fun go(xs: List<Int>, ys: List<Int>) -> List<Int> {
            match xs {
                [] -> ys
                [x, rest...] -> x :: go(rest, ys)
            }
        }
        MkIntList(go(unwrapIntList(a), unwrapIntList(b)))
    }
}

instance ConcatSemantics<String> {
    fun concatSem(a: String, b: String) -> String {
        // Recursive on char list
        fun go(xs: List<Char>, ys: String) -> String {
            match xs {
                [] -> ys
                [c, rest...] -> go(rest, ys)  // simplified - just demonstrate structure
            }
        }
        a ++ b  // use built-in for actual concat
    }
}

// Test ConcatSemantics
il1 = MkIntList([1, 2])
il2 = MkIntList([3, 4])
print(unwrapIntList(concatSem(il1, il2)))              // [1, 2, 3, 4]
print([1, 2] ++ [3, 4])                                // [1, 2, 3, 4]
print(unwrapIntList(concatSem(il1, il2)) == ([1, 2] ++ [3, 4]))  // true

print(concatSem("Hello", " World"))                    // Hello World
print("Hello" ++ " World")                             // Hello World

// Derived: flatten
fun flattenSem(xss: List<List<Int>>) -> List<Int> {
    match xss {
        [] -> []
        [xs, rest...] -> xs ++ flattenSem(rest)
    }
}

print(flattenSem([[1, 2], [3], [4, 5]]))               // [1, 2, 3, 4, 5]

// =============================================
// ConsSemantics — prepend element to list
// =============================================
// Built-in: :: operator

// Cons is primitive, but we can implement using match
fun cons<T>(x: T, xs: List<T>) -> List<T> {
    x :: xs
}

// Test cons
print(cons(1, [2, 3]))                                 // [1, 2, 3]
print((1 :: [2, 3]) == cons(1, [2, 3]))                // true

// Derived: replicate using cons
fun replicate<T>(n: Int, x: T) -> List<T> {
    if n <= 0 { [] }
    else { cons(x, replicate(n - 1, x)) }
}

print(replicate(5, "a"))                               // ["a", "a", "a", "a", "a"]

// Derived: range using cons
fun rangeSem(start: Int, end: Int) -> List<Int> {
    if start > end { [] }
    else { cons(start, rangeSem(start + 1, end)) }
}

print(rangeSem(1, 5))                                  // [1, 2, 3, 4, 5]

// =============================================
// DefaultSemantics<T> — default values
// =============================================
// Built-in: Default<T> with default(Type)

// DefaultSemantics requires a "dummy" argument for type dispatch
trait DefaultSemantics<T> {
    fun getDefaultFor(dummy: T) -> T
}

instance DefaultSemantics<Int> {
    fun getDefaultFor(dummy: Int) -> Int { 0 }
}

instance DefaultSemantics<Float> {
    fun getDefaultFor(dummy: Float) -> Float { 0.0 }
}

instance DefaultSemantics<Bool> {
    fun getDefaultFor(dummy: Bool) -> Bool { false }
}

// Test DefaultSemantics
print(default(Int))                                    // 0
print(getDefaultFor(0))                                // 0
print(default(Int) == getDefaultFor(0))                // true

print(default(Float))                                  // 0.0
print(getDefaultFor(0.0))                              // 0.0

print(default(Bool))                                   // false
print(getDefaultFor(false))                            // false

// Derived: getOrDefault
fun getOrDefaultSem(opt: Option<Int>, dflt: Int) -> Int {
    match opt {
        Some(x) -> x
        Zero -> getDefaultFor(dflt)
    }
}

print(getOrDefaultSem(Some(42), 0))                    // 42
print(getOrDefaultSem(Zero, 0))                        // 0

// =============================================
// FunctorSemantics<F> — mappable containers (HKT)
// =============================================
// Built-in: Functor<F> with fmap
// Semantics: fmapSem applies function to value inside container

trait FunctorSemantics<F> {
    fun fmapSem<A, B>(f: (A) -> B, fa: F<A>) -> F<B>
}

instance FunctorSemantics<Option> {
    fun fmapSem<A, B>(f: (A) -> B, fa: Option<A>) -> Option<B> {
        match fa {
            Some(x) -> Some(f(x))
            Zero -> Zero
        }
    }
}

instance FunctorSemantics<List> {
    fun fmapSem<A, B>(f: (A) -> B, fa: List<A>) -> List<B> {
        match fa {
            [] -> []
            [x, xs...] -> f(x) :: fmapSem(f, xs)
        }
    }
}

instance FunctorSemantics<Result, E> {
    fun fmapSem<A, B>(f: (A) -> B, fa: Result<E, A>) -> Result<E, B> {
        match fa {
            Ok(x) -> Ok(f(x))
            Fail(e) -> Fail(e)
        }
    }
}

// Functor instances for Option, List, Result are now built-in
// No need to define them here

double = fun(x) -> x * 2

// Test Option: FunctorSemantics vs built-in Functor
print(fmapSem(double, Some(21)))                           // Some(42)
print(fmap(double, Some(21)))                              // Some(42)
print(fmapSem(double, Some(21)) == fmap(double, Some(21))) // true

print(fmapSem(double, Zero))                               // Zero
print(fmap(double, Zero))                                  // Zero

// Test List: FunctorSemantics vs built-in Functor
print(fmapSem(double, [1, 2, 3]))                          // [2, 4, 6]
print(fmap(double, [1, 2, 3]))                             // [2, 4, 6]
print(fmapSem(double, [1, 2, 3]) == fmap(double, [1, 2, 3])) // true

// Test Result: FunctorSemantics vs built-in Functor
print(fmapSem(double, Ok(50)))                             // Ok(100)
print(fmap(double, Ok(50)))                                // Ok(100)

print(fmapSem(double, Fail("err")))                        // Fail("err")
print(fmap(double, Fail("err")))                           // Fail("err")

// =============================================
// Functor Laws (verify correctness)
// =============================================

// Law 1: Identity — fmap(id, x) == x
fun idFn<T>(x: T) -> T { x }

opt = Some(42)
print(fmap(idFn, opt) == opt)                              // true

lst = [1, 2, 3]
print(fmap(idFn, lst) == lst)                              // true

// Law 2: Composition — fmap(f ,, g, x) == fmap(f, fmap(g, x))
inc = fun(x) -> x + 1
dbl = fun(x) -> x * 2

opt2 = Some(5)
composed = dbl ,, inc  // (x + 1) * 2

print(fmap(composed, opt2))                                // Some(12)
print(fmap(dbl, fmap(inc, opt2)))                          // Some(12)
print(fmap(composed, opt2) == fmap(dbl, fmap(inc, opt2)))  // true

lst2 = [1, 2, 3]
print(fmap(composed, lst2))                                // [4, 6, 8]
print(fmap(dbl, fmap(inc, lst2)))                          // [4, 6, 8]
print(fmap(composed, lst2) == fmap(dbl, fmap(inc, lst2)))  // true

print("All built-in traits semantics tests passed!")


