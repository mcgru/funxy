
# Erlang-Style Bitstrings in Go: Introducing funbit

**TL;DR:** We brought Erlang's bit syntax to Go to parse binary protocols without the pain. The result is [funbit](https://github.com/funvibe/funbit), a declarative parser for non-byte-aligned data.

## Backstory

While developing **funterm**—a multi-language REPL that combines Python, Lua, JavaScript, and Go—we needed an efficient way to work with binary data. We had to parse network protocols, process structured data, and manipulate bit-level fields.

### What's wrong with manual parsing?

Imagine a real-world task: parsing a data packet from an IoT device where every bit counts. The packet is only 28 bits (3.5 bytes) long and contains several fields:

`| device_id:4 | type:2 | battery:1 | error:1 | value:12 | battery_percent:7 | more:1 |`

The traditional approach in Go turns into a "hell of bitmasks and shifts":

```go
// data := []byte{...}
deviceId := (data[0] >> 4) & 0x0F
sensorType := (data[0] >> 2) & 0x03
batteryLow := (data[0] >> 1) & 0x01
errorFlag := data[0] & 0x01
value := uint16(data[1])<<4 | uint16(data[2]>>4)
batteryPercent := (data[2] >> 1) & 0x7F
moreData := data[2] & 0x01
```

This code is not only hard to write but almost impossible to read and debug.

With `funbit`, the same task is solved declaratively and clearly:

```go
funbit.Integer(m, &deviceId, funbit.WithSize(4))
funbit.Integer(m, &sensorType, funbit.WithSize(2))
funbit.Integer(m, &batteryLow, funbit.WithSize(1))
funbit.Integer(m, &errorFlag, funbit.WithSize(1))
funbit.Integer(m, &value, funbit.WithSize(12))
funbit.Integer(m, &batteryPercent, funbit.WithSize(7))
funbit.Integer(m, &moreData, funbit.WithSize(1))
```

Go provides excellent tools for working with bytes, but when it comes to the bit level or complex protocol parsing, the code quickly becomes cumbersome:

```go
// Typical Go code for parsing a TCP header
srcPort := binary.BigEndian.Uint16(data[0:2])
dstPort := binary.BigEndian.Uint16(data[2:4])
seq := binary.BigEndian.Uint32(data[4:8])
flags := data[13]
urg := (flags >> 5) & 1
ack := (flags >> 4) & 1
// ... and so on
```

In Erlang, the same task is solved elegantly:

```erlang
<<SrcPort:16, DstPort:16, Seq:32, _:64, URG:1, ACK:1, PSH:1, RST:1, SYN:1, FIN:1, _:2, Payload/binary>> = Data
```

So, we implemented this in Go.

## Why existing solutions didn't work for us

Before starting development, we looked at existing libraries for working with binary data in Go:

- `encoding/binary` — great for simple cases, but requires a lot of boilerplate code.
- Various protocol parsers — too specialized, not universal.
- Third-party libraries — either incomplete or don't follow Erlang's semantics.

We needed a solution that:
1. Supports bitstrings of arbitrary length (not just byte-aligned segments).
2. Is compatible with the Erlang/OTP specification.
3. Has a simple API for Go developers.
4. Supports types: integer, float, binary, and UTF-8/16/32.
5. Can handle dynamic sizes and expressions.

## Funbit Architecture

### Builder Pattern for Construction

We chose the builder pattern with deferred error checking. All data-adding operations are performed through functions that take a `builder` as an argument. The error is checked only once at the end, when `Build()` is called.

```go
// Create a builder
builder := funbit.NewBuilder()

// Add segments
funbit.AddInteger(builder, 42, funbit.WithSize(8))
funbit.AddBinary(builder, []byte("data"))
funbit.AddFloat(builder, 3.14, funbit.WithSize(32))

// Build the bitstring and check for an error
bitstring, err := funbit.Build(builder)

// The Matcher works on the same principle
matcher := funbit.NewMatcher()
var num int
var data []byte
var pi float32

funbit.Integer(matcher, &num, funbit.WithSize(8))
funbit.Binary(matcher, &data, funbit.WithSize(4))
funbit.Float(matcher, &pi, funbit.WithSize(32))

results, err := funbit.Match(matcher, bitstring)
```

**Advantages:**
- Clean code without multiple `if err != nil` checks.
- The first error stops processing.
- Subsequent operations are ignored if an error has occurred.

### Matcher for Pattern Matching

```go
matcher := funbit.NewMatcher()
var srcPort, dstPort, seq int
var payload []byte

funbit.Integer(matcher, &srcPort, funbit.WithSize(16))
funbit.Integer(matcher, &dstPort, funbit.WithSize(16)) 
funbit.Integer(matcher, &seq, funbit.WithSize(32))
funbit.RestBinary(matcher, &payload)

results, err := funbit.Match(matcher, bitstring)
```

## Key Technical Decisions

### 1. Bit-level Precision

`funbit` operates at the level of individual bits:

```go
builder := funbit.NewBuilder()
funbit.AddInteger(builder, 0b101, funbit.WithSize(3))  // 3 bits
funbit.AddInteger(builder, 0b1111, funbit.WithSize(4)) // 4 bits
// Total: 7 bits (not a full byte!)
```

### 2. Size Semantics

A **critical difference** between integer and binary segments:

```go
// For an integer: WithSize(32) = 32 BITS
funbit.Integer(matcher, &val, funbit.WithSize(32))  

// For a binary: WithSize(32) = 32 BYTES = 256 BITS!
funbit.Binary(matcher, &data, funbit.WithSize(32))  
```

This matches Erlang's semantics, where:
- `<<Value:32>>` — 32 bits
- `<<Data:32/binary>>` — 32 bytes

### 3. Unit Multipliers

For precise size control:

```go
// Without WithUnit(1): size*8 is interpreted as BYTES
funbit.Binary(matcher, &data, funbit.WithDynamicSizeExpression("size*8"))
// size=5 → 5*8=40, but binary interprets it as 40*8=320 bits!

// With WithUnit(1): size*8 is interpreted as exact BITS  
funbit.Binary(matcher, &data, funbit.WithDynamicSizeExpression("size*8"), funbit.WithUnit(1))
// size=5 → 5*8=40 bits exactly (correct)
```

### 4. UTF Support

Full support for UTF-8/16/32 with correct semantics:

```go
// Encoding a string
funbit.AddUTF8(builder, "Hello €")

// Encoding a single codepoint  
funbit.AddUTF8Codepoint(builder, 0x20AC) // €

// Extracting a codepoint as an INTEGER (per Erlang spec)
var codepoint int
funbit.UTF8(matcher, &codepoint)
```

### 5. Dynamic Sizes

Support for variables and expressions:

```go
// Register a variable
funbit.RegisterVariable(matcher, "size", &size)

// Use it in expressions
funbit.Binary(matcher, &data, funbit.WithDynamicSizeExpression("size*8"), funbit.WithUnit(1))
```

### Example: Nested Protocol

`funbit` shines when parsing protocols where the data size depends on a value in the header.

```go
// Packet structure: [total_size:8][type:8][data:size-2/binary][crc:16]
matcher := funbit.NewMatcher()
var size, pktType int
var data []byte
var crc uint16

// 1. Extract the total size
funbit.Integer(matcher, &size, funbit.WithSize(8))
// 2. Register it as a variable for use in expressions
funbit.RegisterVariable(matcher, "size", &size)
// 3. Extract the remaining fields using the dynamic size
funbit.Integer(matcher, &pktType, funbit.WithSize(8))
funbit.Binary(matcher, &data,
    funbit.WithDynamicSizeExpression("(size-2)*8"), // size-2 bytes = (size-2)*8 bits
    funbit.WithUnit(1)) // Specify that the size is in bits
funbit.Integer(matcher, &crc, funbit.WithSize(16))
```

## Integration with funterm

In the context of `funterm`, the library is used for:

1.  **Parsing protocols in examples:**
    ```erlang
    # In funterm REPL
    lua.packet = <<0xDEADBEEF:32, "payload"/binary>>
    match lua.packet {
        <<header:32, data/binary>> -> lua.print("Header:", header)
    }
    ```

2.  **Cross-language binary data exchange:**
    ```python
    py.data = b"\xDE\xAD\xBE\xEF"
    # Convert to a bitstring for processing in Lua
    ```

3.  **Processing IoT and sensor data:**
    ```erlang  
    lua.sensor_data = <<temp:16/signed, humidity:8, battery:8>>
    ```

## Architectural Characteristics

### Performance

The convenience of declarative syntax comes at the cost of some overhead compared to the standard `encoding/binary`. For most tasks where parsing is not a bottleneck, this is an acceptable trade-off. However, for performance-critical sections of code, we recommend conducting your own profiling.

### Other characteristics

The library was designed with the following in mind:
- **Algorithmic Complexity:** O(n) for construction and matching, where n is the number of segments.
- **Memory:** Bitstrings are immutable, which ensures safety and predictability.
- **Thread Safety:** Created bitstrings (`*BitString` type) are completely thread-safe for reading after creation. However, `Builder` and `Matcher` instances are not thread-safe and should not be used concurrently in different goroutines without external synchronization.

### When to use funbit (and when not to)

**Ideal scenarios:**
- Parsing network protocols: TCP, UDP, DNS, or any custom binary protocols.
- Working with IoT and embedded data: Convenient handling of compact, non-byte-aligned data structures.
- Parsing file formats: Working with PNG, MP3, GIF, and other formats at a low level.
- Researching and documenting protocols.
- Prototyping parsers.
- Learning about binary protocols.
- Parsing complex structures with dynamic sizes.
- Tasks where correctness and readability are important.

**When `encoding/binary` might be better:**
- When all data is perfectly byte-aligned and has a fixed size.
- For high-load systems with millions of packets/sec.
- For game servers with strict latency requirements.
- For embedded systems with limited resources.

```go
// Example of correct usage in goroutines
var mu sync.Mutex

// Operations with the builder must be protected
mu.Lock()
builder := funbit.NewBuilder()
funbit.AddInteger(builder, 123, funbit.WithSize(8))
bitstring, err := funbit.Build(builder)
mu.Unlock()

// The created bitstring can be safely read from different goroutines
go processData(bitstring)
go analyzeData(bitstring)
```

- **Readability vs. Performance:** The priority was given to code readability and correctness.

## Development Challenges

### 1. Compatibility with Erlang Semantics

The hardest part was accurately reproducing Erlang's behavior:
- Different interpretation of sizes for different types.
- Correct handling of UTF codepoints.
- Behavior on errors (equivalent to `badarg`).

### 2. Go Typing vs. Erlang Dynamics

Erlang is dynamically typed; Go is statically typed. This created many problems:

**Problem 1: Dynamic types in patterns**
```erlang
% In Erlang, a variable can be of any type
<<Value/binary>> = Data  % Value can be a string
<<Value:32>> = Data      % Value can be a number
```

```go
// In Go, different variables are needed for different types
var binaryValue []byte
var intValue int
funbit.Binary(matcher, &binaryValue)
funbit.Integer(matcher, &intValue, funbit.WithSize(32))
```

**Problem 2: Universal interface for values**
In Erlang, all values have a common type. In Go, we had to use `interface{}`:

```go
func AddInteger(b *Builder, value interface{}, options ...SegmentOption)
```

But this required runtime type checks and led to a loss of compile-time safety.

**Problem 3: Sizes and units**
```erlang
% In Erlang, size is interpreted differently for different types
<<Value:32>>        % 32 bits for an integer
<<Data:32/binary>>  % 32 BYTES for a binary
```

```go
// In Go, we had to do explicit type checks at runtime
if segment.Type == TypeInteger {
    // size in bits
} else if segment.Type == TypeBinary {
    // size in bytes (units)
}
```

**Problem 4: Error handling**
In Erlang, errors like `badarg` are thrown at runtime. In Go, we had to decide whether to:
- Panic (not the Go way).
- Return errors from each function (verbose).
- Accumulate errors in the builder (our choice).

**Solution: Compromises**
1.  **Type safety at the API level** — different functions for different types.
2.  **Internal runtime checks** — an unavoidable evil for Erlang compatibility.
3.  **Deferred error handling** — the builder pattern with error accumulation.
4.  **Explicit size semantics** — clear separation of bits and bytes in the documentation.

### 3. Performance of Bitwise Operations

Efficiently working with non-byte-aligned data required optimizing bit-shifting and masking algorithms.

### 4. Size Semantics — a headache

The most insidious problem was the different interpretation of sizes:

```erlang
% In Erlang:
<<Data:4/binary>>    % 4 BYTES
<<Value:4>>          % 4 BITS  
<<Text:4/utf8>>      % 4 CODEPOINTS
```

**The problem:** The same parameter `4` means different things!

**Our solution:**
```go
// Explicitly specify the units
funbit.WithSize(4)              // Default depends on the type
funbit.WithSize(4, WithUnit(8)) // 4 * 8 = 32 bits
funbit.WithSize(4, WithUnit(1)) // Exactly 4 bits
```

**Why was this hard?**
1.  **Backward compatibility** — we needed to reproduce Erlang's behavior exactly.
2.  **Intuitiveness** — a developer expects `WithSize(4)` for a binary to mean 4 bytes.
3.  **Validation** — we needed to check the correctness of size+type+unit combinations.
4.  **Documentation** — each case required a detailed explanation.

**Result:** A lot of time was spent on testing edge cases and writing documentation with examples.

### 5. UTF Encoding — subtleties and pitfalls

UTF support in Erlang is very flexible, which created problems when porting:

**Problem 1: Strings vs. codepoints**
```erlang
% Erlang supports both options:
<<"Hello"/utf8>>     % Encodes the whole string
<<1024/utf8>>        % Encodes a single codepoint
```

**Our solution:**
```go
// Different functions for different cases
funbit.AddUTF8(builder, "Hello")           // String
funbit.AddUTF8Codepoint(builder, 1024)     // Codepoint
```

**Problem 2: Codepoint validation**
Erlang throws a `badarg` for invalid codepoints. We had to reproduce this exact behavior:

```go
// Check Unicode ranges
if codepoint > 0x10FFFF || (codepoint >= 0xD800 && codepoint <= 0xDFFF) {
    return NewBitStringError(ErrInvalidUnicodeCodepoint, ...)
}
```

**Problem 3: Endianness for UTF-16/32**
UTF-16 and UTF-32 can be big-endian or little-endian, which complicated the API:

```go
funbit.AddUTF16(builder, "text", funbit.WithEndianness("big"))
```

**Development Time:** UTF support took up ~30% of the entire project time due to the many edge cases and the need for full compliance with Erlang's behavior.

## Future Plans

1.  Performance optimization for large bitstrings.
2.  Expanded protocol support (HTTP/2, gRPC, etc.).
3.  Integration with code generation for automatic parser creation.
4.  Streaming support for processing large data streams.

## Conclusion

Creating `funbit` showed that elegant solutions from one ecosystem can be successfully adapted to another while maintaining the idiomatic style of the target language.

**Links:**
- [funbit GitHub repository](https://github.com/funvibe/funbit)
- [funterm GitHub repository](https://github.com/funvibe/funterm)
- [funterm demo video](https://youtu.be/ZvNyiXGb5f4?si=7p77eGyQLXrlAniT)
- [Erlang Bit Syntax Specification](https://www.erlang.org/doc/programming_examples/bit_syntax.html)

The library is open to the community and we welcome your feedback, comments, and suggestions!

<cut text="Practical Examples"/>

### Parsing a PNG Header

```go
// Construction
builder := funbit.NewBuilder()
funbit.AddInteger(builder, 13, funbit.WithSize(32))        // Length
funbit.AddBinary(builder, []byte("IHDR"))                  // Type
funbit.AddInteger(builder, 1920, funbit.WithSize(32))      // Width
funbit.AddInteger(builder, 1080, funbit.WithSize(32))      // Height
funbit.AddInteger(builder, 8, funbit.WithSize(8))          // Bit depth
bitstring, _ := funbit.Build(builder)

// Pattern matching
matcher := funbit.NewMatcher()
var length, width, height, bitDepth int
var chunkType []byte

funbit.Integer(matcher, &length, funbit.WithSize(32))
funbit.Binary(matcher, &chunkType, funbit.WithSize(4))     // 4 bytes
funbit.Integer(matcher, &width, funbit.WithSize(32))
funbit.Integer(matcher, &height, funbit.WithSize(32))
funbit.Integer(matcher, &bitDepth, funbit.WithSize(8))
results, err := funbit.Match(matcher, bitstring)

if err == nil && string(chunkType) == "IHDR" {
    fmt.Printf("PNG: %dx%d, %d-bit\n", width, height, bitDepth)
}
```

### TCP Header with Flags

```go
builder := funbit.NewBuilder()
funbit.AddInteger(builder, 0x1234, funbit.WithSize(16))     // Source port
funbit.AddInteger(builder, 0x5678, funbit.WithSize(16))     // Dest port
funbit.AddInteger(builder, 0x12345678, funbit.WithSize(32)) // Sequence
funbit.AddInteger(builder, 0x87654321, funbit.WithSize(32)) // Ack
funbit.AddInteger(builder, 5, funbit.WithSize(4))           // DataOffset (minimum 5)
funbit.AddInteger(builder, 0, funbit.WithSize(6))           // Reserved

// Flags as individual bits
funbit.AddInteger(builder, 1, funbit.WithSize(1)) // URG
funbit.AddInteger(builder, 0, funbit.WithSize(1)) // ACK
funbit.AddInteger(builder, 1, funbit.WithSize(1)) // PSH
funbit.AddInteger(builder, 0, funbit.WithSize(1)) // RST
funbit.AddInteger(builder, 1, funbit.WithSize(1)) // SYN
funbit.AddInteger(builder, 0, funbit.WithSize(1)) // FIN
funbit.AddInteger(builder, 8192, funbit.WithSize(16))     // Window size
funbit.AddInteger(builder, 0, funbit.WithSize(16))        // Checksum
funbit.AddInteger(builder, 0, funbit.WithSize(16))        // Urgent pointer

funbit.AddBinary(builder, []byte("payload"))
```
