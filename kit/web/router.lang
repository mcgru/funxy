package web

import "lib/list" (foldl, filter, map)
import "lib/string" (stringSplit, stringReplaceAll, stringJoin)
import "lib/tuple" (fst, snd)
import "lib/map" (mapGet, mapPut)

// --- ADT for Radix Tree ---

type NodeType = Static | Param | Wildcard

type Node = MkNode NodeType String Option<Handler> List<Node>

// Router now holds a map of roots (one per HTTP method)
// roots: Map<Method, RootNode>
type Router = MkRouter Map<String, Node> List<Middleware> Handler ((Context, String) -> Result<String, HttpResponse>)

fun newRouter() {
    // Default handlers
    defaultNotFoundHandler = fun(ctx) -> Result<String, HttpResponse> {
        res: HttpResponse = resText("Not Found") |> withStatus(404)
        Ok(res)
    }

    defaultErrorHandler = fun(ctx, err) -> Result<String, HttpResponse> {
        res: HttpResponse = resText("Internal Server Error") |> withStatus(500)
        Ok(res)
    }

    // Initialize with empty map of roots
    MkRouter(%{}, [], defaultNotFoundHandler, defaultErrorHandler)
}

fun addRoute(method, path, handler, r) {
    match r {
        MkRouter(roots, mws, notFoundHandler, errorHandler) -> {
            // Get or create root node for this method
            root = match mapGet(roots, method) {
                Some(n) -> n
                Zero -> MkNode(Static, "/", Zero, [])
            }

            // Split path into segments, ignoring empty strings (e.g. initial /)
            parts = stringSplit(path, "/")
            segments = parts |> filter(fun(s) { s != "" })

            // Insert handler into the tree
            newRoot = insertNode(root, segments, handler)

            // Update roots map
            newRoots = mapPut(roots, method, newRoot)

            MkRouter(newRoots, mws, notFoundHandler, errorHandler)
        }
    }
}

fun insertNode(node, segments, handler) {
    match segments {
        [] -> {
            // End of path, set handler on this node
            match node {
                MkNode(t, s, _, children) -> MkNode(t, s, Some(handler), children)
            }
        }
        [seg, rest...] -> {
            match node {
                MkNode(typ, s, h, children) -> {
                    // Determine type of the next segment
                    nextSegInfo = if len(stringSplit(seg, ":")) > 1 {
                        (Param, stringReplaceAll(seg, ":", ""))
                    } else if seg == "*" {
                        (Wildcard, "_wildcard") // Default name for wildcard
                    } else {
                        (Static, seg)
                    }
                    childType = fst(nextSegInfo)
                    childSeg = snd(nextSegInfo)

                    // Find if a matching child already exists
                    // We split children into (matching, others)
                    // matchChild returns (Option<Node>, List<Node>)
                    matchResult = findMatchingChild(children, childType, childSeg)
                    matchOpt = fst(matchResult)
                    otherChildren = snd(matchResult)

                    newChild = match matchOpt {
                        Some(c) -> insertNode(c, rest, handler)
                        Zero -> createChain(childType, childSeg, rest, handler)
                    }

                    // Reconstruct children list, maintaining priority order
                    // Static > Param > Wildcard
                    // Since we removed the matching child (if any) from otherChildren,
                    // we just need to insert newChild into otherChildren at the right place.
                    newChildren = insertChildSorted(otherChildren, newChild)

                    MkNode(typ, s, h, newChildren)
                }
            }
        }
    }
}

// Create a chain of nodes for the remaining segments
fun createChain(typ, seg, rest, handler) {
    match rest {
        [] -> MkNode(typ, seg, Some(handler), [])
        [nextSeg, nextRest...] -> {
            nextSegInfo = if len(stringSplit(nextSeg, ":")) > 1 {
                (Param, stringReplaceAll(nextSeg, ":", ""))
            } else if nextSeg == "*" {
                (Wildcard, "_wildcard")
            } else {
                (Static, nextSeg)
            }
            nextType = fst(nextSegInfo)
            nextS = snd(nextSegInfo)
            child = createChain(nextType, nextS, nextRest, handler)
            MkNode(typ, seg, Zero, [child])
        }
    }
}

// Find a child with matching type and segment
// Returns (Option<FoundNode>, List<OtherNodes>)
fun findMatchingChild(children, typ, seg) {
    foldl(fun(acc, child) {
        found = fst(acc)
        others = snd(acc)
        match child {
            MkNode(ct, cs, _, _) -> {
                if ct == typ && cs == seg {
                    (Some(child), others)
                } else {
                    (found, others ++ [child])
                }
            }
        }
    }, (Zero, []), children)
}

// Insert a child into the list keeping order: Static < Param < Wildcard
fun insertChildSorted(children, newChild) {
    // 0=Static, 1=Param, 2=Wildcard
    rank = fun(node) {
        match node {
            MkNode(Static, _, _, _) -> 0
            MkNode(Param, _, _, _) -> 1
            MkNode(Wildcard, _, _, _) -> 2
        }
    }

    newRank = rank(newChild)

    // Split into (lessOrEqual, greater)
    // Actually we just need to insert before the first one with greater rank
    // But since we want to group same ranks, let's just append if same rank?
    // Order within same rank doesn't strictly matter for correctness, but maybe for determinism.

    // Simple approach: partition by rank
    statics = children |> filter(fun(c) { rank(c) == 0 })
    params = children |> filter(fun(c) { rank(c) == 1 })
    wildcards = children |> filter(fun(c) { rank(c) == 2 })

    match newRank {
        0 -> (statics ++ [newChild]) ++ params ++ wildcards
        1 -> statics ++ (params ++ [newChild]) ++ wildcards
        2 -> statics ++ params ++ (wildcards ++ [newChild])
        _ -> children ++ [newChild] // Should not happen
    }
}

// Find a route in the router
// Returns Option<(Handler, Map<String, String>)>
fun findRoute(router, method, path) {
    match router {
        MkRouter(roots, _, _, _) -> {
            match mapGet(roots, method) {
                Zero -> Zero
                Some(root) -> {
                    parts = stringSplit(path, "/")
                    segments = parts |> filter(fun(s) { s != "" })
                    matchNode(root, segments, %{})
                }
            }
        }
    }
}

// Recursive matching
fun matchNode(node, segments, params) {
    match segments {
        [] -> {
            // End of path, check if this node has a handler
            match node {
                MkNode(_, _, handlerOpt, _) -> match handlerOpt {
                    Some(h) -> Some((h, params))
                    Zero -> Zero // Node exists but no handler (intermediate node)
                }
            }
        }
        [seg, rest...] -> {
            match node {
                MkNode(_, _, _, children) -> {
                    // Try children in order
                    // children are already sorted by priority
                    searchChildren(children, seg, rest, params)
                }
            }
        }
    }
}

fun searchChildren(children, seg, rest, params) {
    match children {
        [] -> Zero // No match found
        [child, otherChildren...] -> {
            match child {
                MkNode(typ, childSeg, _, _) -> {
                    match typ {
                        Static -> {
                            if childSeg == seg {
                                // Match exact segment
                                res = matchNode(child, rest, params)
                                match res {
                                    Some(_) -> res
                                    Zero -> searchChildren(otherChildren, seg, rest, params) // Backtrack
                                }
                            } else {
                                searchChildren(otherChildren, seg, rest, params)
                            }
                        }
                        Param -> {
                            // Match param, capture value
                            newParams = mapPut(params, childSeg, seg)
                            res = matchNode(child, rest, newParams)
                            match res {
                                Some(_) -> res
                                Zero -> searchChildren(otherChildren, seg, rest, params)
                            }
                        }
                        Wildcard -> {
                            // Match wildcard (greedy match rest of path)
                            // Wildcard captures everything remaining.
                            // Reconstruct the rest of the path
                            suffix = stringJoin([seg] ++ rest, "/")
                            newParams = mapPut(params, childSeg, suffix)

                            // Check if this wildcard node has a handler
                            match child {
                                MkNode(_, _, handlerOpt, _) -> match handlerOpt {
                                    Some(h) -> Some((h, newParams))
                                    Zero -> Zero // Wildcard without handler?
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fun get(path, handler, r) { addRoute("GET", path, handler, r) }
fun post(path, handler, r) { addRoute("POST", path, handler, r) }
fun options(path, handler, r) { addRoute("OPTIONS", path, handler, r) }

fun use(mw, r) {
    match r {
        MkRouter(roots, mws, notFoundHandler, errorHandler) -> MkRouter(roots, mws ++ [mw], notFoundHandler, errorHandler)
    }
}

fun setNotFoundHandler(r, handler) {
    match r {
        MkRouter(roots, mws, _, errorHandler) -> MkRouter(roots, mws, handler, errorHandler)
    }
}

fun setErrorHandler(r, handler) {
    match r {
        MkRouter(roots, mws, notFoundHandler, _) -> MkRouter(roots, mws, notFoundHandler, handler)
    }
}

